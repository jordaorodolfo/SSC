# This file was *autogenerated* from the file model.sage.
from sage.all_cmdline import *   # import sage library
#------------------------------------------------------
# helper functions
#------------------------------------------------------
def vectorAngle2D(vec):
    return atan(vec[Integer(1)]/vec[Integer(0)])

def formatLatex(string,replacements):
    for key in replacements:
        string = string.replace(key,replacements[key])
    return string

def partialDiff(expr,variable):
    temp = var('temp')
    return diff(expr.subs({variable:temp}),temp).subs({temp:variable})

@parallel(verbose=True,timeout=Integer(60))
def parSimp(a):
    return a.full_simplify()

def cubicRoots(func):
  from sage.symbolic.expression_conversions import PolynomialConverter
  s = var('s')
  print(func(s))
  p = PolynomialConverter(func(s), ring=CC['s'])
  # coefs = [pol.coefficient({s:i}) for i in range(degree(p))]
  return p.roots()
#------------------------------------------------------

#--------------------
# global utils
#--------------------
verbose=True
C_USE_DATA=True
#--------------------

#------------------------------------------------------
# Latex Replacements
#------------------------------------------------------
replacements = {'D[0]\\left(\\theta_{1}\\right)\\left(t\\right)':'\\dot\\theta_1',
                   'D[0]\\left(\\theta_{2}\\right)\\left(t\\right)':'\\dot\\theta_2',
                    'D[0]\\left(y_{2}\\right)\\left(t\\right)':'\\dot y_2',
                    'D[0]\\left(y_{1}\\right)\\left(t\\right)':'\\dot y_1',
                   '\\cos\\left(\\theta_{1}\\left(t\\right)\\right)':'c_1',
                   '\\sin\\left(\\theta_{1}\\left(t\\right)\\right)':'s_1',
                   '\\cos\\left(\\theta_{2}\\left(t\\right)\\right)':'c_2',
                   '\\sin\\left(\\theta_{2}\\left(t\\right)\\right)':'s_2',
               '\\cos\\left(\\theta_{2}\\left(\\theta_{1}\\left(t\\right)\\right)\\right)':'c_2',
               '\\sin\\left(\\theta_{2}\\left(\\theta_{1}\\left(t\\right)\\right)\\right)':'s_2',
               'D[0]\\left(\\theta_{2}\\right)\\left(\\theta_{1}\\left(t\\right)\\right)':'\\dot\\theta_2',
               'D[0, 0]\\left(\\theta_{2}\\right)\\left(\\theta_{1}\\left(t\\right)\\right)':'\\ddot\\theta_2',
               'D[0, 0]\\left(\\theta_{1}\\right)\\left(t\\right)':'\\ddot\\theta_1',
               'D[0]\\left(\\theta_{1}\\right)\\left(t\\right)':'\\dot\\theta_1',
               'D[0]\\left(y_{2}\\right)\\left(\\theta_{1}\\left(t\\right)\\right)':'\\dot{{y_2}}',
               'D[0, 0]\\left(y_{2}\\right)\\left(\\theta_{1}\\left(t\\right)\\right)':'\\ddot{{y_2}}',
               'D[0]\\left(y_{1}\\right)\\left(\\theta_{1}\\left(t\\right)\\right)':'\\dot{{y_1}}',
               'D[0, 0]\\left(y_{1}\\right)\\left(\\theta_{1}\\left(t\\right)\\right)':'\\ddot{{y_1}}',
               'y_{2}\\left(\\theta_{1}\\left(t\\right)\\right)':'y_2',
               'y_{1}\\left(\\theta_{1}\\left(t\\right)\\right)':'y_1'}
#------------------------------------------------------

#------------------------------------------------------
# variables definitions
#------------------------------------------------------
if verbose:
   print('----------defining variables----------')
x = var('x')
torque = var('tau')
g = vector([Integer(0),-var('g_0')])
L = {i:var('L_{}'.format(i)) for i in range(Integer(1),Integer(4))}
a = {i:var('a_{}'.format(i)) for i in range(Integer(1),Integer(3))}
c = {'x':var('c_x'),'y':var('c_y')}
d = {i:var('d_{}'.format(i)) for i in range(Integer(1),Integer(5))}
d['x'] = var('d_x')
d['y'] = var('d_y')
theta_1 = var('theta_1')
__tmp__=var("x"); K = symbolic_expression(Integer(1)/Integer(2)*(L[Integer(1)]**Integer(2)-(d['x']**Integer(2)+d['y']**Integer(2)+d[Integer(1)]**Integer(2)+d[Integer(2)]**Integer(2)+Integer(2)*(d['x']*d[Integer(1)]*cos(x)+d['y']*d[Integer(1)]*sin(x))))).function(x)
__tmp__=var("x"); coef_sin = symbolic_expression(d['x']*d[Integer(1)]+d[Integer(1)]*d[Integer(2)]*cos(x)).function(x)
__tmp__=var("x"); coef_cos = symbolic_expression(d['y']*d[Integer(2)]+d[Integer(1)]*d[Integer(2)]*sin(x)).function(x)
__tmp__=var("x"); theta_2 = symbolic_expression(acos((coef_cos(x)*K(x)+sqrt(coef_sin(x)**Integer(2)+coef_cos(x)**Integer(2)-K(x)**Integer(2)))/(coef_sin(x)**Integer(2)+coef_cos(x)**Integer(2)))).function(x)
__tmp__=var("x"); y_1 = symbolic_expression(-d[Integer(3)]*sin(x)+sqrt(L[Integer(2)]**Integer(2)-(a[Integer(1)]-d[Integer(3)]*cos(x))**Integer(2))).function(x)
__tmp__=var("x"); y_2 = symbolic_expression(-d[Integer(4)]*sin(x)+sqrt(L[Integer(3)]**Integer(2)-(a[Integer(2)]-d[Integer(4)]*cos(x))**Integer(2))).function(x)
cmC = {Integer(1):vector([Integer(0),Integer(0)]),Integer(2):vector([c['x'],c['y']])}
cmP = {Integer(1):vector([d[Integer(1)]*sin(theta_2(theta_1)), d[Integer(1)]*cos(theta_2(theta_1))]),
       Integer(2):cmC[Integer(2)]+vector([d[Integer(1)]*cos(theta_1), d[Integer(2)]*sin(theta_1)]),
       Integer(3):vector([d[Integer(3)]*cos(theta_2(theta_1)), d[Integer(3)]*sin(theta_2(theta_1))]),
       Integer(4):-vector([d[Integer(4)]*cos(theta_2(theta_1)), d[Integer(4)]*sin(theta_2(theta_1))]),
       Integer(5):vector([a[Integer(1)],-y_1(theta_2)]),
       Integer(6):vector([a[Integer(2)],-y_2(theta_2)])}
cmL = {Integer(1):Integer(1)/Integer(2)*(cmP[Integer(1)]+cmP[Integer(2)]),
      Integer(2):Integer(1)/Integer(2)*(cmP[Integer(4)]+cmP[Integer(6)]),
      Integer(3):Integer(1)/Integer(2)*(cmP[Integer(3)]+cmP[Integer(5)])}
alphaP = {Integer(1):theta_1,
         Integer(2):theta_2(theta_1),
         Integer(3):theta_2(theta_1),
         Integer(4):theta_2(theta_1),
         Integer(5):Integer(0),
         Integer(6):Integer(0)}
alphaL = {Integer(1):vectorAngle2D(cmL[Integer(1)]),
         Integer(2):vectorAngle2D(cmL[Integer(2)]),
         Integer(3):vectorAngle2D(cmL[Integer(3)])}
alphaC = {Integer(1):theta_1,
         Integer(2):theta_2(theta_1)}
rL = {i:var('r_L_{}'.format(i)) for i in range(Integer(1),len(cmL)+Integer(1))}
rP = {i:var('r_P_{}'.format(i)) for i in range(Integer(1),len(cmP)+Integer(1))}
rC = {i:var('r_C_{}'.format(i)) for i in range(Integer(1),len(cmC)+Integer(1))}
mP = {i:var('m_P_{}'.format(i)) for i in range(Integer(1),len(cmP)+Integer(1))}
mL = {i:var('m_L_{}'.format(i)) for i in range(Integer(1),len(cmL)+Integer(1))}
mC = {i:var('m_C_{}'.format(i)) for i in range(Integer(1),len(cmC)+Integer(1))}
IP = {i:var('I_P_{}'.format(i)) for i in range(Integer(1),len(cmP)+Integer(1))}
IL = {i:var('I_L_{}'.format(i)) for i in range(Integer(1),len(cmL)+Integer(1))}
IC = {i:var('I_C_{}'.format(i)) for i in range(Integer(1),len(cmP)+Integer(1))}
#------------------------------------------------------

#------------------------------------------------------
# Measurements
#------------------------------------------------------
if C_USE_DATA:
    if verbose:
        print('----------inputing data----------')
    data = {L[Integer(1)]:RealNumber('0.127'),
            L[Integer(2)]:RealNumber('0.265'),
            L[Integer(3)]:RealNumber('0.265'),
            a[Integer(1)]:RealNumber('0.006'),
            a[Integer(2)]:RealNumber('0.006'),
            d['x']:RealNumber('0.116'),
            d['y']:RealNumber('0.033'),
            c['x']:RealNumber('0.116'),
            c['y']:RealNumber('0.033'),
            d[Integer(1)]:RealNumber('0.005'),
            d[Integer(2)]:RealNumber('0.035'),
            d[Integer(3)]:RealNumber('0.027'),
            d[Integer(4)]:RealNumber('0.027'),
            mL[Integer(1)]:RealNumber('0.15'),
            mL[Integer(2)]:RealNumber('0.20'),
            mL[Integer(3)]:RealNumber('0.20'),
            mP[Integer(1)]:Integer(0),
            mP[Integer(2)]:Integer(0),
            mP[Integer(3)]:Integer(0),
            mP[Integer(4)]:Integer(0),
            mP[Integer(5)]:Integer(0),
            mP[Integer(6)]:Integer(0),
            rL[Integer(1)]:RealNumber('0.016'),
            rL[Integer(2)]:RealNumber('0.016'),
            rL[Integer(3)]:RealNumber('0.016'),
            rP[Integer(1)]:Integer(0),
            rP[Integer(2)]:Integer(0),
            rP[Integer(3)]:Integer(0),
            rP[Integer(4)]:Integer(0),
            rP[Integer(5)]:Integer(0),
            rP[Integer(6)]:Integer(0),
            rC[Integer(1)]:RealNumber('0.40'),
            rC[Integer(2)]:RealNumber('0.60'),
            mC[Integer(1)]:RealNumber('0.8'),
            mC[Integer(2)]:RealNumber('1.0'),
            g_0:RealNumber('9.8665')}
for i in range(Integer(1),len(cmL)+Integer(1)):
  data[IL[i]] = data[mL[i]]*data[rL[i]]**Integer(2)
for i in range(Integer(1),len(cmP)+Integer(1)):
  data[IP[i]] = data[mP[i]]*data[rP[i]]**Integer(2)
for i in range(Integer(1),len(cmC)+Integer(1)):
  data[IC[i]] = data[mC[i]]*data[rC[i]]**Integer(2)
#------------------------------------------------------


#------------------------------------------------------
# Functions of the system
#------------------------------------------------------
if verbose:
   print('----------computing potential functions----------')
__tmp__=var("theta_1"); V = symbolic_expression(sum([mP[i]/Integer(2)*diff(cmP[i],theta_1)*diff(cmP[i],theta_1) for i in range(Integer(1),len(cmP)+Integer(1))])).function(theta_1)
__tmp__=var("theta_1"); V = symbolic_expression(V(theta_1) + sum([IP[i]/Integer(2)*partialDiff(alphaP[i],theta_1)*partialDiff(alphaP[i],theta_1) for i in range(Integer(1),len(cmP)+Integer(1))])).function(theta_1)
__tmp__=var("theta_1"); V = symbolic_expression(V(theta_1) + sum([mL[i]/Integer(2)*partialDiff(cmL[i],theta_1)*partialDiff(cmL[i],theta_1) for i in range(Integer(1),len(cmL)+Integer(1))])).function(theta_1)
__tmp__=var("theta_1"); V = symbolic_expression(V(theta_1) + sum([IL[i]/Integer(2)*partialDiff(alphaL[i],theta_1)*partialDiff(alphaL[i],theta_1) for i in range(Integer(1),len(cmL)+Integer(1))])).function(theta_1)
__tmp__=var("theta_1"); V = symbolic_expression(V(theta_1) + sum([IC[i]/Integer(2)*partialDiff(alphaC[i],theta_1)*partialDiff(alphaC[i],theta_1) for i in range(Integer(1),len(cmC)+Integer(1))])).function(theta_1)
__tmp__=var("theta_1"); U = symbolic_expression(sum([-mP[i]*cmP[i]*g for i in range(Integer(1),len(cmP)+Integer(1))])).function(theta_1)
__tmp__=var("theta_1"); U = symbolic_expression(U(theta_1) + sum([-mL[i]*cmL[i]*g for i in range(Integer(1),len(cmL)+Integer(1))])).function(theta_1)
__tmp__=var("theta_1"); U = symbolic_expression(U(theta_1) + sum([-mC[i]*cmC[i]*g for i in range(Integer(1),len(cmC)+Integer(1))])).function(theta_1)
#------------------------------------------------------

# #------------------------------------------------------
# # Equations of motion
# #------------------------------------------------------
# if verbose:
#    print('----------computing equations of motion----------')
# eqm = diff(diff(theta_1,t),t)*2*V(theta_1) + diff(theta_1,t)**2*partialDiff(V(theta_1),theta_1)+partialDiff(U(theta_1),theta_1)
# #------------------------------------------------------

#------------------------------------------------------
# Assumptions and Simplification
#------------------------------------------------------
if verbose:
   print('----------making assumptions----------')
assume(d[Integer(3)]==d[Integer(4)])
assume(L[Integer(2)]==L[Integer(3)])
assume(mL[Integer(2)]==mL[Integer(3)])
assume(mP[Integer(1)]==mP[Integer(2)])
assume(mP[Integer(2)]==mP[Integer(3)])
assume(mP[Integer(3)]==mP[Integer(4)])
assume(IL[Integer(2)]==IL[Integer(3)])
assume(cmC[Integer(2)][Integer(0)]>Integer(0))
assume(cmC[Integer(2)][Integer(1)]>Integer(0))
assume(a[Integer(1)]==a[Integer(2)])
assume(d['x']==cmC[Integer(1)][Integer(0)])
assume(d['y']==cmC[Integer(1)][Integer(1)])
#------------------------------------------------------

#------------------------------------------------------
# Symbolic Linearization
#------------------------------------------------------
if verbose:
   print('----------computing linear coeficients----------')
#-------------------------
# equilbrium point
#-------------------------
# W = (L[1]**2-(d['x']**2+d['y']**2+d[1]**2+d[2]**2))/2-d['y']*d[2]
# z1 = d['x']*d[1]
# z2 = d[1]*(d['y']+d[2])
# eq_point=(z1*W+z2*sqrt(z2**2+z1**2-W**2))/(z2**2+z1**2)
eq_point = Integer(0)
#-------------------------
lin_a = Integer(2)*diff(V(theta_1),theta_1).subs(theta_1=eq_point)
lin_c = Integer(2)*diff(diff(U(theta_1),theta_1),theta_1).subs(theta_1=eq_point)
lin_b = Integer(0)
lin_d = -Integer(2)*diff(diff(U(theta_1),theta_1),theta_1).subs(theta_1=eq_point)*eq_point
lin_a = lin_a.subs(data)
lin_b = lin_b.subs(data)
lin_c = lin_c.subs(data)
lin_d = lin_d.subs(data)
#------------------------------------------------------

#------------------------------------------------------
# ARE
#------------------------------------------------------
if verbose:
  print('----------computing system model----------')
N = Integer(51)
k_t = Integer(243)/Integer(10000)
k_f = Integer(0)
k_e = Integer(1)/Integer(393)
Lind = Integer(143)/Integer(1000)/Integer(1000)
R = Integer(127)/Integer(100)
J = Integer(219)/Integer(10000)/Integer(100)/Integer(100)
model_matrix = matrix([
[-R/Lind,k_e/Lind,Integer(0)],
[N**Integer(2)*k_t/J/(N**Integer(2)-lin_a),((lin_b-N**Integer(2)*k_e)/(N**Integer(2)-lin_a))/J,lin_c/J/(N**Integer(2)-lin_a)],
[Integer(0),Integer(1),Integer(0)]
])
input_matrix = matrix([
[Integer(1)/Lind],
[Integer(0)],
[Integer(0)]
])
exeogenous_matrix = matrix([
[Integer(0)],
[lin_d/J/(N**Integer(2)-lin_a)],
[Integer(0)]
])
#------------------------------------------------------

#------------------------------------------------------
# transfer functions
#------------------------------------------------------
if verbose:
  print('----------computing transfer functions----------')
s = var('s')
K_p, T_i = var('K_p, T_i')
__tmp__=var("s"); NC = symbolic_expression(K_p*(T_i*s+Integer(1))).function(s)
__tmp__=var("s"); DC = symbolic_expression(T_i*s).function(s)
__tmp__=var("s"); NG = symbolic_expression((input_matrix[Integer(0),Integer(0)]*s*(s-model_matrix[Integer(0),Integer(0)]))).function(s)
__tmp__=var("s"); DG = symbolic_expression((s**Integer(3)-(model_matrix[Integer(0),Integer(0)]+model_matrix[Integer(1),Integer(1)])*s**Integer(2)+(model_matrix[Integer(0),Integer(0)]*model_matrix[Integer(1),Integer(1)]-model_matrix[Integer(0),Integer(1)]-model_matrix[Integer(1),Integer(2)])*s+(model_matrix[Integer(0),Integer(0)]*model_matrix[Integer(1),Integer(2)]))).function(s)
__tmp__=var("s"); NH = symbolic_expression(NG(s)*NC(s)).function(s)
__tmp__=var("s"); DH = symbolic_expression(NG(s)*NC(s) + DG(s)*DC(s)).function(s)
#------------------------------------------------------

#------------------------------------------------------
# Gain calculation
#------------------------------------------------------
if verbose:
  print('----------computing optimal gain----------')
roots1 = cubicRoots(DG(s))
roots2 = cubicRoots(DG(-s))
#--------------------------
# construct linear system for optimization
#--------------------------



#------------------------------------------------------
# simplification
#------------------------------------------------------
# if verbose:
#   print('----------attempting simplifications----------')
# eqm = simplify(eqm)
# lin_eqm = simplify(lin_eqm)
# a1 = simplify(a1)
# b1 = simplify(b1)
# c1 = simplify(c1)
# d1 = simplify(d1)
#------------------------------------------------------

#------------------------------------------------------
# Output
#------------------------------------------------------
if verbose:
  print('----------writing output----------')
with open('./Log_Report/lin_a.tex','w') as archive:
  string = formatLatex(latex(lin_a),replacements)
  # if len(string) > 100000:
  #   archive.write(string[:100000]+'\n')
  #   archive.write(string[100000:])
  # else:
  archive.write(string)
with open('./Log_Report/lin_c.tex','w') as archive:
  string = formatLatex(latex(lin_c),replacements)
  # if len(string) > 100000:
  #   archive.write(string[:100000]+'\n')
  #   archive.write(string[100000:])
  # else:
  archive.write(string)
with open('./Log_Report/lin_d.tex','w') as archive:
  string = formatLatex(latex(lin_d),replacements)
  # if len(string) > 100000:
  #   archive.write(string[:100000]+'\n')
  #   archive.write(string[100000:])
  # else:
  archive.write(string)
#------------------------------------------------------

#------------------------------------------------------
# debugging
#------------------------------------------------------
print(roots1,roots2)
#------------------------------------------------------
